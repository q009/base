// shadow map filters, arg1 enables color sampling

smfilterg5 = [result [
    @(? (> $usetexgather 1) [
        #define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
    ] [
        #define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
    ])
    #define colorshadowgather(center, xoff, yoff, comp) textureGatherOffset(tex10, center, ivec2(xoff, yoff), comp)

    float filtercomp(vec4 g1, vec4 g2, vec4 g3, vec4 g4, vec4 g5,
        vec4 g6, vec4 g7, vec4 g8, vec4 g9, vec2 offset)
    {
        vec4 locols = vec4(g1.ab, g3.ab);
        vec4 hicols = vec4(g7.rg, g9.rg);
        locols.yz += g2.ab;
        hicols.yz += g8.rg;
        vec4 midcols = vec4(g1.rg, g3.rg) + vec4(g7.ab, g9.ab) +
                       vec4(g4.rg, g6.rg) + vec4(g4.ab, g6.ab) +
                       mix(locols, hicols, offset.y);
        vec4 cols = g5 + vec4(g2.rg, g8.ab);
        cols.xyz += mix(midcols.xyz, midcols.yzw, offset.x);
        return dot(cols, vec4(1.0/25.0));
    }

    vec3 filtershadow(vec3 shadowtc)
    {
        vec2 offset = fract(shadowtc.xy - 0.5);
        vec2 center = (shadowtc.xy - offset) * shadowatlasscale;

        vec4 g1[3];
        vec4 g2[3];
        vec4 g3[3];
        vec4 g4[3];
        vec4 g5[3];
        vec4 g6[3];
        vec4 g7[3];
        vec4 g8[3];
        vec4 g9[3];

        g1[0] = g1[1] = g1[2] = shadowgather(center, -2, -2);
        g2[0] = g2[1] = g2[2] = shadowgather(center,  0, -2);
        g3[0] = g3[1] = g3[2] = shadowgather(center,  2, -2);
        g4[0] = g4[1] = g4[2] = shadowgather(center, -2,  0);
        g5[0] = g5[1] = g5[2] = shadowgather(center,  0,  0);
        g6[0] = g6[1] = g6[2] = shadowgather(center,  2,  0);
        g7[0] = g7[1] = g7[2] = shadowgather(center, -2,  2);
        g8[0] = g8[1] = g8[2] = shadowgather(center,  0,  2);
        g9[0] = g9[1] = g9[2] = shadowgather(center,  2,  2);

        @(if $arg1 [result [
            for(int comp = 0; comp < 3; comp++)
            {
                g1[comp] *= colorshadowgather(center, -2, -2, comp);
                g2[comp] *= colorshadowgather(center,  0, -2, comp);
                g3[comp] *= colorshadowgather(center,  2, -2, comp);
                g4[comp] *= colorshadowgather(center, -2,  0, comp);
                g5[comp] *= colorshadowgather(center,  0,  0, comp);
                g6[comp] *= colorshadowgather(center,  2,  0, comp);
                g7[comp] *= colorshadowgather(center, -2,  2, comp);
                g8[comp] *= colorshadowgather(center,  0,  2, comp);
                g9[comp] *= colorshadowgather(center,  2,  2, comp);
            }

            return vec3(
                filtercomp(g1[0], g2[0], g3[0], g4[0], g5[0], g6[0], g7[0], g8[0], g9[0], offset),
                filtercomp(g1[1], g2[1], g3[1], g4[1], g5[1], g6[1], g7[1], g8[1], g9[1], offset),
                filtercomp(g1[2], g2[2], g3[2], g4[2], g5[2], g6[2], g7[2], g8[2], g9[2], offset)
            );
        ]] [result [
            return vec3(filtercomp(g1[0], g2[0], g3[0], g4[0], g5[0], g6[0], g7[0], g8[0], g9[0], offset));
        ]])
    }
]]

smfilterg3 = [result [
    @(? (> $usetexgather 1) [
        #define shadowgather(center, xoff, yoff) textureGatherOffset(tex4, center, shadowtc.z, ivec2(xoff, yoff))
    ] [
        #define shadowgather(center, xoff, yoff) step(shadowtc.z, textureGatherOffset(tex4, center, ivec2(xoff, yoff)))
    ])
    #define colorshadowgather(center, xoff, yoff, comp) textureGatherOffset(tex10, center, ivec2(xoff, yoff), comp)

    float filtercomp(vec4 g1, vec4 g2, vec4 g3, vec4 g4, vec2 offset)
    {
        vec4 cols = vec4(g1.rg, g2.rg) +
            vec4(g3.ab, g4.ab) +
            mix(vec4(g1.ab, g2.ab), vec4(g3.rg, g4.rg), offset.y);

        return dot(mix(cols.xyz, cols.yzw, offset.x), vec3(1.0/9.0));
    }

    vec3 filtershadow(vec3 shadowtc)
    {
        vec2 offset = fract(shadowtc.xy - 0.5);
        vec2 center = (shadowtc.xy - offset) * shadowatlasscale;

        vec4 g1[3];
        vec4 g2[3];
        vec4 g3[3];
        vec4 g4[3];

        g1[0] = g1[1] = g1[2] = shadowgather(center, -1, -1);
        g2[0] = g2[1] = g2[2] = shadowgather(center,  1, -1);
        g3[0] = g3[1] = g3[2] = shadowgather(center, -1,  1);
        g4[0] = g4[1] = g4[2] = shadowgather(center,  1,  1);

        @(if $arg1 [result [
            for(int comp = 0; comp < 3; comp++)
            {
                g1[comp] *= colorshadowgather(center, -1, -1, comp);
                g2[comp] *= colorshadowgather(center,  1, -1, comp);
                g3[comp] *= colorshadowgather(center, -1,  1, comp);
                g4[comp] *= colorshadowgather(center,  1,  1, comp);
            }

            return vec3(
                filtercomp(g1[0], g2[0], g3[0], g4[0], offset),
                filtercomp(g1[1], g2[1], g3[1], g4[1], offset),
                filtercomp(g1[2], g2[2], g3[2], g4[2], offset)
            );
        ]] [result [
            return vec3(filtercomp(g1[0], g2[0], g3[0], g4[0], offset));
        ]])
    }
]]

smfilterb5 = [result [
    #define shadowval(xy, xoff, yoff) vec3(float(shadow2DRect(tex4, vec3(xy + vec2(xoff, yoff), shadowtc.z))))
    #define colorshadowval(xy, xoff, yoff) shadowcolor(xy + vec2(xoff, yoff))

    float filtercomp(vec3 t[9], int comp, vec4 size)
    {
        vec4 vals1 = vec4(t[0][comp], t[1][comp], t[2][comp], t[3][comp]);
        vec4 vals2 = vec4(t[4][comp], t[5][comp], t[6][comp], t[7][comp]);

        return (1.0/25.0)*dot(size.zxzx*size.wwyy, vals1) +
            (2.0/25.0)*dot(size, vals2) +
            (4.0/25.0)*t[8][comp];
    }

    vec3 filtershadow(vec3 shadowtc)
    {
        vec2 offset = fract(shadowtc.xy - 0.5);
        vec4 center = vec4(shadowtc.xy - offset + 0.5, shadowtc.xy - offset*0.5);
        vec4 size = vec4(offset + 1.0, 2.0 - offset);
        vec3 taps[9];

        taps[0] = shadowval(center.zw, -1.5, -1.5);
        taps[1] = shadowval(center.zw,  2.0, -1.5);
        taps[2] = shadowval(center.zw, -1.5,  2.0);
        taps[3] = shadowval(center.zw,  2.0,  2.0);
        taps[4] = shadowval(center.zy,  2.0,  0.0);
        taps[5] = shadowval(center.xw,  0.0,  2.0);
        taps[6] = shadowval(center.zy, -1.5,  0.0);
        taps[7] = shadowval(center.xw,  0.0, -1.5);
        taps[8] = shadowval(center.xy,  0.0,  0.0);

        @(if $arg1 [result [
            vec3 opaquefilter = vec3(filtercomp(taps, 0, size));

            taps[0] = colorshadowval(center.zw, -1.5, -1.5);
            taps[1] = colorshadowval(center.zw,  2.0, -1.5);
            taps[2] = colorshadowval(center.zw, -1.5,  2.0);
            taps[3] = colorshadowval(center.zw,  2.0,  2.0);
            taps[4] = colorshadowval(center.zy,  2.0,  0.0);
            taps[5] = colorshadowval(center.xw,  0.0,  2.0);
            taps[6] = colorshadowval(center.zy, -1.5,  0.0);
            taps[7] = colorshadowval(center.xw,  0.0, -1.5);
            taps[8] = colorshadowval(center.xy,  0.0,  0.0);

            return opaquefilter * vec3(
                filtercomp(taps, 0, size),
                filtercomp(taps, 1, size),
                filtercomp(taps, 2, size)
            );
        ]] [result [
            return vec3(filtercomp(taps, 0, size));
        ]])
    }
]]

smfilterb3 = [result [
    #define shadowval(center, xoff, yoff) vec3(float(shadow2DRect(tex4, center + vec3(xoff, yoff, 0.0))))
    #define colorshadowval(center, xoff, yoff) shadowcolor(center.xy + vec2(xoff, yoff))

    float filtercomp(vec3 t[4], int comp, vec4 size)
    {
        vec4 vals = vec4(t[0][comp], t[1][comp], t[2][comp], t[3][comp]);
        return (1.0/9.0)*dot(size.zxzx*size.wwyy, vals);
    }

    vec3 filtershadow(vec3 shadowtc)
    {
        vec2 offset = fract(shadowtc.xy - 0.5);
        vec3 center = shadowtc;
        center.xy -= offset*0.5;
        vec4 size = vec4(offset + 1.0, 2.0 - offset);
        vec3 taps[4];

        taps[0] = shadowval(center, -0.5, -0.5);
        taps[1] = shadowval(center,  1.0, -0.5);
        taps[2] = shadowval(center, -0.5,  1.0);
        taps[3] = shadowval(center,  1.0,  1.0);

        @(if $arg1 [result [
            vec3 opaquefilter = vec3(filtercomp(taps, 0, size));

            taps[0] = colorshadowval(center, -0.5, -0.5);
            taps[1] = colorshadowval(center,  1.0, -0.5);
            taps[2] = colorshadowval(center, -0.5,  1.0);
            taps[3] = colorshadowval(center,  1.0,  1.0);

            return opaquefilter * vec3(
                filtercomp(taps, 0, size),
                filtercomp(taps, 1, size),
                filtercomp(taps, 2, size)
            );
        ]] [result [
            return vec3(filtercomp(taps, 0, size));
        ]])
    }
]]

smfilterrg = [result [
    #define shadowval(center, xoff, yoff) vec3(float(shadow2DRect(tex4, center + vec3(xoff, yoff, 0.0))))
    #define colorshadowval(center, xoff, yoff) shadowcolor(center.xy + vec2(xoff, yoff))

    float filtercomp(vec3 t[4], int comp)
    {
        vec4 vals = vec4(t[0][comp], t[1][comp], t[2][comp], t[3][comp]);
        return dot(vec4(0.25), vals);
    }

    vec3 filtershadow(vec3 shadowtc)
    {
        vec3 taps[4];
        taps[0] = shadowval(shadowtc, -0.4,  1.0);
        taps[1] = shadowval(shadowtc, -1.0, -0.4);
        taps[2] = shadowval(shadowtc,  0.4, -1.0);
        taps[3] = shadowval(shadowtc,  1.0,  0.4);

        @(if $arg1 [result [
            taps[0] *= colorshadowval(shadowtc, -0.4,  1.0);
            taps[1] *= colorshadowval(shadowtc, -1.0, -0.4);
            taps[2] *= colorshadowval(shadowtc,  0.4, -1.0);
            taps[3] *= colorshadowval(shadowtc,  1.0,  0.4);

            return vec3(
                filtercomp(taps, 0),
                filtercomp(taps, 1),
                filtercomp(taps, 2)
            );
        ]] [result [
            return vec3(filtercomp(taps, 0));
        ]])
    }
]]

smfilternone = [result [
    vec3 filtershadow(vec3 shadowtc)
    {
        vec3 result = vec3(float(shadow2DRect(tex4, shadowtc)));
        @(if $arg1 [result [
            result *= shadowcolor(shadowtc.xy);
        ]])
        return result;
    }
]]
